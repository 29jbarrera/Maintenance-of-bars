{
  "version": 3,
  "sources": ["../../../../../../../../../libs/server/src/lib/trpc/utils/decoke-and-verify-token.ts"],
  "sourcesContent": ["import * as jose from 'jose';\n\nconst privateKey = new TextEncoder().encode(process.env['jwtSecrectKey']);\nexport type JWTDecode = {\n  id: string;\n};\n\nexport async function decoke_and_verify_token(\n  token: string\n): Promise<null | JWTDecode> {\n  if (!token) return null;\n\n  try {\n    const { payload } = await jose.jwtVerify(token, privateKey, {\n      algorithms: ['HS512'],\n    });\n\n    return payload as JWTDecode;\n  } catch (error) {\n    // console.error(error);\n    return null;\n  }\n}\n\nexport async function encode(data: any) {\n  const token = await new jose.SignJWT(data)\n    .setProtectedHeader({\n      alg: 'HS512',\n    })\n    .sign(privateKey);\n  return token;\n}\n\nimport * as bcrypt from 'bcrypt';\nconst saltRounds = 15;\n\nexport async function hashPassword(password: string) {\n  const hash = await bcrypt.hash(password, saltRounds);\n  return hash;\n}\n\nexport async function comparePassword(password: string, hash: string) {\n  const match = await bcrypt.compare(password, hash);\n  return match;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAsB;AAiCtB,aAAwB;AA/BxB,MAAM,aAAa,IAAI,YAAY,EAAE,OAAO,QAAQ,IAAI,eAAe,CAAC;AAKxE,eAAsB,wBACpB,OAC2B;AAC3B,MAAI,CAAC;AAAO,WAAO;AAEnB,MAAI;AACF,UAAM,EAAE,QAAQ,IAAI,MAAM,KAAK,UAAU,OAAO,YAAY;AAAA,MAC1D,YAAY,CAAC,OAAO;AAAA,IACtB,CAAC;AAED,WAAO;AAAA,EACT,SAAS,OAAO;AAEd,WAAO;AAAA,EACT;AACF;AAEA,eAAsB,OAAO,MAAW;AACtC,QAAM,QAAQ,MAAM,IAAI,KAAK,QAAQ,IAAI,EACtC,mBAAmB;AAAA,IAClB,KAAK;AAAA,EACP,CAAC,EACA,KAAK,UAAU;AAClB,SAAO;AACT;AAGA,MAAM,aAAa;AAEnB,eAAsB,aAAa,UAAkB;AACnD,QAAM,OAAO,MAAM,OAAO,KAAK,UAAU,UAAU;AACnD,SAAO;AACT;AAEA,eAAsB,gBAAgB,UAAkB,MAAc;AACpE,QAAM,QAAQ,MAAM,OAAO,QAAQ,UAAU,IAAI;AACjD,SAAO;AACT;",
  "names": []
}
